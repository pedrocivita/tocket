export interface StackInfo {
  language: string;
  runtime: string;
  build: string;
  framework: string;
  extras: string[];
}

export const executorMd = (
  projectName: string,
  description: string,
  executorName = "Claude Code",
  architectFile = "GEMINI.md",
) =>
  `# ${projectName} — Executor Instructions

<!-- LLM_CONTEXT: Executor instructions for ${executorName} -->
<!-- Generated by Tocket CLI -->

## Role

You are the **Executor** (${executorName}) for **${projectName}**.
${description ? `\n> ${description}\n` : ""}
Your job is to **implement**, not to plan. Read the Memory Bank before every session, follow the Architect's decisions, and write code.

---

## Rules

1. **Always read \`.context/\` first** — Start every session by reading activeContext.md and systemPatterns.md.
2. **Follow the Architect's plan** — Implementation decisions come from \`${architectFile}\` or mission briefs. Do not redesign.
3. **Ask before deviating** — If the plan is unclear or blocked, ask the user. Do not improvise architecture.
4. **Write code in English** — Variables, functions, comments, commits — all in \`en-US\`.
5. **Update Memory Bank on completion** — After finishing a task, update activeContext.md with what changed.

---

## Memory Bank

| File | Purpose |
|------|---------|
| \`.context/activeContext.md\` | Current focus, recent changes, open decisions |
| \`.context/systemPatterns.md\` | Architecture patterns, tech stack, conventions |
| \`${architectFile}\` | Architect instructions (read-only for you) |

---

## Workflow

\`\`\`
1. Read .context/  →  2. Receive task  →  3. Implement  →  4. Update .context/
\`\`\`
`;

/** @deprecated Use executorMd instead */
export const claudeMd = executorMd;

export const architectMd = (
  projectName: string,
  description: string,
  architectName = "Gemini",
  executorName = "Claude Code",
  executorFile = "CLAUDE.md",
) =>
  `# ${projectName} — Architect Instructions

<!-- LLM_CONTEXT: Architect instructions for ${architectName} -->
<!-- Generated by Tocket CLI -->

## Role

You are the **Architect** (${architectName}) for **${projectName}**.
${description ? `\n> ${description}\n` : ""}
Your job is to **analyze, plan, and decide**. You do not write code directly — you produce structured mission briefs that the Executor (${executorName}) implements.

---

## Rules

1. **Read \`.context/\` first** — Understand current state before planning.
2. **Produce payloads** — Use \`<payload version="2.0">\` XML format for handoff to the Executor.
3. **Never write code inline** — Provide specs, not implementations. The Executor handles code.
4. **Update systemPatterns.md** — When you make architectural decisions, record them.
5. **Think in constraints** — Define what the system should and should not do.

---

## Memory Bank

| File | Purpose |
|------|---------|
| \`.context/activeContext.md\` | Current focus, recent changes, open decisions |
| \`.context/systemPatterns.md\` | Architecture patterns, tech stack, conventions |
| \`${executorFile}\` | Executor instructions (read-only for you) |

---

## Payload Format

\`\`\`xml
<payload version="2.0">
  <meta>
    <intent>What needs to happen</intent>
    <scope>Which files/modules are affected</scope>
    <priority>high | medium | low</priority>
  </meta>
  <context>
    <summary>Background and reasoning</summary>
    <architect-decisions>Key decisions made</architect-decisions>
  </context>
  <tasks>
    <task id="1" type="create|edit|delete">
      <target>file/path</target>
      <action>What to do</action>
      <spec>Detailed specification</spec>
      <done>Definition of done</done>
    </task>
  </tasks>
  <validate>
    <check>Verification step</check>
  </validate>
</payload>
\`\`\`
`;

/** @deprecated Use architectMd instead */
export const geminiMd = architectMd;

export const activeContextMd = (projectName: string) =>
  `# Active Context - ${projectName}

<!-- Updated by both Architect and Executor after each session -->

## Current Focus

_No active tasks yet. Run \`tocket generate\` to create your first mission brief._

## Recent Changes

| Date | Change | Agent |
|------|--------|-------|
| ${new Date().toISOString().split("T")[0]} | Initialized agentic workspace | Tocket CLI |

## Open Decisions

_None yet._
`;

export const systemPatternsMd = (
  projectName: string,
  architectName = "Gemini",
  executorName = "Claude Code",
) =>
  `# System Patterns - ${projectName}

<!-- Architectural decisions and conventions. Updated by the Architect. -->

## Tech Stack

_To be defined by the Architect._

## Architecture Patterns

_To be defined._

## Conventions

- Code language: \`en-US\`
- Commit language: \`en-US\`
- Triangulation: ${architectName} (Architect) + ${executorName} (Executor)

## Key Decisions

| Decision | Rationale | Date |
|----------|-----------|------|
| Adopted Tocket triangulation | Structured multi-agent workflow | ${new Date().toISOString().split("T")[0]} |
`;

export const productContextMd = (projectName: string, description: string) =>
  `# Product Context - ${projectName}

<!-- What the product is, who it's for, and why it exists. Updated by the Architect. -->

## What is ${projectName}?

${description || "_Describe your product here._"}

## Problem

_What problem does this project solve?_

## Solution

_How does it solve it?_

## Target Users

_Who is this for?_

## Design Principles

- _List the guiding principles for this project_
`;

export const techContextMd = (projectName: string, stack?: StackInfo) => {
  const lang = stack?.language || "";
  const rt = stack?.runtime || "";
  const bld = stack?.build || "";
  const fw = stack?.framework || "";
  const extras = stack?.extras?.length
    ? `\n### Notable Dependencies\n\n${stack.extras.map((d) => `- \`${d}\``).join("\n")}\n`
    : "";

  return `# Tech Context - ${projectName}

<!-- Stack, build tools, and critical rules. Updated by the Architect. -->

## Stack

| Layer | Technology | Notes |
|-------|-----------|-------|
| Language | ${lang} | ${lang ? "Auto-detected by Tocket" : ""} |
| Runtime | ${rt} | ${rt ? "Auto-detected by Tocket" : ""} |
| Build | ${bld} | ${bld ? "Auto-detected by Tocket" : ""} |
| Framework | ${fw} | ${fw ? "Auto-detected by Tocket" : ""} |
${extras}
## Critical Rules

_Document any rules that agents must follow (e.g., import conventions, naming patterns)._

## Project Structure

\`\`\`
${projectName}/
  src/         # Source code
  .context/    # Memory Bank
\`\`\`
`;
};

export const progressMd = (projectName: string) =>
  `# Progress Log - ${projectName}

<!-- Appended by tocket sync and manual updates -->

## Milestone: Project Initialization

**Status**: Complete

- [x] Agentic workspace scaffolded with Tocket CLI
- [x] Memory Bank initialized (\`.context/\`)

## Next Up

- [ ] _Define your first milestone here_
`;

export const cursorrulesMd = (
  projectName: string,
  description: string,
  architectFile = "ARCHITECT.md",
) =>
  `# .cursorrules - ${projectName}

# Generated by Tocket CLI — compatible with Cursor IDE

## Role

You are the **Executor** (Cursor) for **${projectName}**.
${description ? `\n> ${description}\n` : ""}
Your job is to **implement**, not to plan. Read the Memory Bank before every session, follow the Architect's decisions, and write code.

## Rules

1. **Always read \`.context/\` first** — Start every session by reading activeContext.md and systemPatterns.md.
2. **Follow the Architect's plan** — Implementation decisions come from \`${architectFile}\` or mission briefs. Do not redesign.
3. **Ask before deviating** — If the plan is unclear or blocked, ask the user. Do not improvise architecture.
4. **Write code in English** — Variables, functions, comments, commits — all in \`en-US\`.
5. **Update Memory Bank on completion** — After finishing a task, update activeContext.md with what changed.

## Memory Bank

| File | Purpose |
|------|---------|
| \`.context/activeContext.md\` | Current focus, recent changes, open decisions |
| \`.context/systemPatterns.md\` | Architecture patterns, tech stack, conventions |
| \`${architectFile}\` | Architect instructions (read-only for you) |

## Workflow

\`\`\`
1. Read .context/  →  2. Receive task  →  3. Implement  →  4. Update .context/
\`\`\`
`;

export const tocketMd = (
  projectName: string,
  executorFile = "CLAUDE.md",
  architectFile = "GEMINI.md",
) =>
  `# Tocket Protocol Specification

> How any AI agent should operate in **${projectName}**.

This file is **agent-agnostic**. Whether you are Claude, Gemini, GPT, Cursor, Cline, Copilot, or any future AI — if you see this file, follow these rules.

---

## 1. Memory Bank

Project context lives in \`.context/\`, not in chat history. **Read it before doing anything.**

\`\`\`
.context/
  activeContext.md    <- Start here. Current focus, recent changes, open decisions.
  systemPatterns.md   <- Architecture patterns, conventions, key decisions.
  techContext.md      <- Tech stack, build tools, critical rules.
  productContext.md   <- What the product is, who it's for, why it exists.
  progress.md         <- What's done, what's next.
\`\`\`

### Rules

- **Read before acting** — Always read \`activeContext.md\` and \`systemPatterns.md\` before your first action in a session.
- **Write before leaving** — Update \`activeContext.md\` with what changed after completing significant work.
- **Trust the files** — If \`.context/\` says the project uses ESM, it uses ESM. Don't second-guess documented decisions.
- **Don't duplicate** — Context belongs in \`.context/\`, not scattered in code comments or chat summaries.

---

## 2. Triangulation

Tocket separates **planning** from **implementation** across two agent roles:

\`\`\`
┌─────────────────┐          ┌─────────────────┐
│    ARCHITECT     │          │    EXECUTOR      │
│  (Planner)       │  payload │  (Implementer)   │
│                  │─────────>│                  │
│  Analyzes task   │          │  Receives plan   │
│  Designs approach│          │  Writes code     │
│  Generates XML   │          │  Runs tests      │
│  Updates patterns│          │  Updates context  │
└─────────────────┘          └─────────────────┘
\`\`\`

### Architect

- Reads \`.context/\` to understand current state
- Produces structured payloads (see Section 3) with clear tasks
- Makes architectural decisions and records them in \`systemPatterns.md\`
- **Does not write code** — only specs and constraints

### Executor

- Reads \`.context/\` and the Architect's payload
- Implements tasks exactly as specified
- Asks when the plan is unclear — does not improvise architecture
- Updates \`activeContext.md\` and \`progress.md\` after completing work

### Solo Mode

Not every task needs triangulation. For simple, well-defined changes, a single agent can act as both Architect and Executor. The Memory Bank rules still apply.

---

## 3. Payloads

A payload is the structured handoff from Architect to Executor.

### Minimal Example

\`\`\`xml
<payload version="2.0">
  <meta>
    <intent>Goal in one line</intent>
    <scope>Files affected</scope>
    <priority>high | medium | low</priority>
  </meta>
  <tasks>
    <task id="1" type="create | edit | delete">
      <target>file/path</target>
      <action>What to do</action>
      <done>Definition of done</done>
    </task>
  </tasks>
  <validate>
    <check>How to verify success</check>
  </validate>
</payload>
\`\`\`

---

## Quick Start

1. Read this file (\`TOCKET.md\`)
2. Read \`.context/activeContext.md\` for current state
3. Read your role-specific config (\`${executorFile}\` or \`${architectFile}\`)
4. Proceed with your task, following the Memory Bank rules above
`;
